# 収集ロジック・コアアルゴリズム詳細設計

**Date:** 2026/01/16
**Author:** Pekokana
**Status:** Design Freeze
**Version:** 1.1
---

## 1. Bulk Read（一括読み出し）の設計方針

### 1.1. 導入の目的

Modbus通信（特にシリアル通信やネットワーク遅延がある環境）において、通信のオーバーヘッドを最小化し、設定された収集周期（`sample_interval`）を厳守するために導入します。

* **非効率**: 各アドレスに対して個別にリクエスト（通信回数増、遅延蓄積）。
* **効率的**: 連続または近接するアドレスを一つのブロックとして一括取得（通信回数削減）。

---

## 2. Bulk Read アルゴリズムの階層構造（案2採用版）

グループ化の判定は、以下の優先順位（階層）に従って厳格に行われます。

* **第1階層：周期（Interval）**
* 同じ `sample_interval` のものだけを集める。周期が異なるものは、ストレージ肥大化防止のため決して統合しない。


* **第2階層：接続先（Host）**
* 同じPLC/デバイス（`host_id`）へのリクエストに分ける。


* **第3階層：種別（RegType）**
* Coil、Holding Register等、Modbusのファンクションコードが異なるものは別グループとする。


* **第4階層：距離（Address Gap）**
* `MAX_GAP` 以内に収まるアドレス範囲を1つのBulk Readコマンドとして集約する。



---

## 3. 具体的なグルーピング・ロジック

エンジン起動時および設定更新時に、以下の手順で「読み出しグループ」を動的に生成します。

### 3.1. 生成ステップ

1. DBから有効なアイテム一覧を取得し、上記の階層順（`sample_interval` > `host_id` > `reg_type` > `address`）でソートする。
2. ソートされたリストを順に走査し、同一の `Interval / Host / RegType` 枠内でアドレス距離を判定する。
3. **判定式**:
`現在のアイテムアドレス - (直前のアイテムアドレス + 長さ) <= MAX_GAP`
* **真**: 現在のグループに統合。読み出し範囲（Count）を拡張。
* **偽**: 新しいグループを作成。



---

## 4. 実行エンジンのスケジューリング

### 4.1. タイマー駆動型マルチプレクサ

プロセス/スレッドの乱立を防ぐため、単一のエンジンが複数の周期を管理します。

* **インターバル・マネージャー**: `sample_interval` ごとにアイテムグループをバケット化して管理。
* **収集スケジューラ**: 1秒単位のチック（鼓動）に合わせ、`現在の秒 % sample_interval == 0` となるグループのみを抽出して実行キューへ送る。

---

## 5. エラーハンドリング：段階的切り分け（Step-down recovery）

一括読み出しグループ内に「不正アドレス」が含まれていた場合、グループ全体の通信が失敗するリスクに対応します。

1. **一括読み出し実行**: 例外（Illegal Address等）が発生した場合、即座に個別読み出しへフォールバック。
2. **個別切り分け**: グループ内の全アイテムを「1つずつ」通信し、エラーの犯人を特定する。
* **成功**: 通常通り処理を継続。`last_status` を `0` (OK) に更新。
* **失敗**: 対象アイテムの `last_status` を `2` (Address Error) に変更。


3. **一時除外**: `last_status` がエラーのアイテムは、次回以降のバルクリード計算から除外（スキップ）し、健全なアイテムの収集効率を維持する。

---

## 6. ストレージ最適化戦略

### 6.1. 変化時保存（Change-based Recording）

SQLiteの肥大化を抑えるため、意味のある変化があったときのみ `history` テーブルへ記録します。

* **判定ロジック**:

```python
# 変化が update_threshold を超えた場合のみ保存
diff = abs(current_value - last_value)
if diff > update_threshold:
    save_to_history(item_id, current_value)
    update_item_cache(item_id, current_value) # DB上の last_value を更新

```

### 6.2. 間引き（Housekeeping）

* `items.history_retention_days` に基づき、古いデータを自動削除。
* 高頻度データ（1s周期）は短期間、低頻度データ（1h周期）は長期間保持するなど、アイテムごとの個別設定を適用する。

---

## 7. DBスキーマへの反映（状態管理カラム）

| カラム名 | 説明 |
| --- | --- |
| `last_value` | 変化判定（Change-based Recording）用の前回値キャッシュ。 |
| `last_status` | アイテムの健全性（0:OK, 1:CommErr, 2:AddrErr）。 |
| `update_threshold` | 記録を行う最小の変化量（デッドバンド）。 |
